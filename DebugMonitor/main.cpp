/****************************************************************************
*							   Дипломный проект					   		    *
* Тема: Разработка отладочного комплекса для процессора						* 
*       с архитектурой Sparc v8.											*
*****************************************************************************
* Язык: С++                                                                 *
* Среда: Microsoft Visual Studio 2013                                       *
* Разработал: Шипугин В.А., Яковлев В.А.                                                 *
* Название программы: DebugMonitor                                          *
*****************************************************************************
* Глобальные переменные:						                            *
* hCOM – указатель на открытый COM-порт;                                    *
* ArrayWatch - массив, хранящий значения аппаратных точек остановок;        *
* ArrayBreak - массив, хранящий значения программных точек остановок;       *
* CountWatch - переменная, хранящая количество аппаратных точек остановок;	*
* p – переменная, хранящая промежуточные значения menu;                     *
* ReadBuffer – массив для прочтенных данных;                                *
* WriteBuffer – массив для записанных данных.                               *
*****************************************************************************
* Функции, использующиеся в программе:                                      *
* Mem -  функция чтения участка памяти по указанному адресу;                *
* Wmem – функция записи данных по указанному адресу;                        *
* Init – функция инициализации COM - порта;                                 *
* InitFull – функция первоначальной инициализации COM - порта;              *
* isNum - функция проверки парамметра на число;                             *
* isHex - функция проверки параметра на шеснадчатеричность;                 *
* isHexOrDec - функция проверки параметра на разрядность;                   *
* swp - функция переворота данных;											*
* WriteSwap - функция записи перевернутых данных;							*
* SwapReg - функция переворота регистров;									*
* WriteBreak – функция Записи точек остановок;								*
* Help – функция команды Help;												*
* MenuMem - функция команды Mem;											*
* MenuWmem - функция команды Wmem;											*
* Load - функция загрузки файла-приложения в память;						*
* Watch - функция установки аппаратных точек остановок;						*
* Break - функция установки программных точек остановок;					*
* Delete - функция удаления точек остановок;								*
* Run - функция выполнения программы с указаннного адреса;					*
* Step - функция выполнения одного или нескольки шагов программы;			*
* Continue - функция продолжения выполнения программы;						*
* DebugMode - функция активации/деактивации отладочного режима процессора;	*
* Disassembler - функция дизассемблирования участка памяти;					*
* Reg - функция вывода регистров окна;										*
* main - функция основной программы.										*
****************************************************************************/

#define _CRT_SECURE_NO_WARNINGS
#include <iostream>
#include <stdlib.h>
#include <stdio.h>
#include <fstream>
#include <string>
#include <locale.h>
#include <windows.h>
#include "dis.h"
using namespace std;

HANDLE hCOM;																// Объявление глобальных переменных. 
char *p;
int ArrayWatch[2][2] = {0}, ArrayBreak[2][4] = {0}, CountWatch = 0;
unsigned char ReadBuffer[300] = {0}, WriteBuffer[300] = {0};

/****************************************************************************
* Mem -  Функция чтения участка памяти по указанному адресу.                *
*****************************************************************************
* Формальные параметры:                                                     *
* Address – переменная хранящая адрес чтения;                               *
* CountDoubleWord - переменная, хранящая количество двойных слов для чтения;*
* Buffer - переменная, хранящая результирующие данные.                      *
*****************************************************************************
* Локальные переменные:                                                     *
* Command – массив для команды чтения;                                      *
* i – счетчик, для формирования команды чтения.                             *
****************************************************************************/

int Mem(unsigned int Address, int CountDoubleWord, unsigned char *Buffer)								
{	
	char Command[5] = { 0 };
	int i = 0; 
	if (CountDoubleWord == 0)												// Проверка дины чтения.
	{
		cout << "Неверная длина чтения." << endl;
		return 0;
    }
	Command[0] = 0x80 | ((CountDoubleWord - 1) & 0x3F);						// Формирование адреса.
	for (i = 0; i < 4; i++)													// Переворот адреса.
    {
		Command[1 + i] = ((unsigned char *)&Address)[3 - i];
    }
	WriteFile(hCOM, Command, 5, (LPDWORD)&i, NULL);							// Отправка команды.
	ReadFile(hCOM, Buffer, 4 * CountDoubleWord, (LPDWORD)&i, NULL);			// Прием ответа.
	if (i != 4 * CountDoubleWord)											// Проверка выполнения команды.
    {
		cout << "Ошибка чтения, проверьте подключение.\a" << endl;
		return 0;
    }
	return 1;
}

/****************************************************************************
* Wmem – Функция записи данных по указанному адресу.                        *
*****************************************************************************
* Формальные параметры:                                                     *
* Address – переменная хранящая адрес записи;                               *
* CountDoubleWord - переменная, хранящая количество двойных слов для записи;*
* Buffer - переменная, хранящая результирующие данные.                      *
*****************************************************************************
* Локальные переменные:                                                     *
* Command – массив для команды записи;                                      *
* i – счетчик, для формирования команды записи.								*
****************************************************************************/

int Wmem(unsigned int Address, int CountDoubleWord, unsigned char *Buffer)								
{	
	char Command[5] = {0};
	int i = 4;
	Command[0] = 0xC0 | ((CountDoubleWord - 1) & 0x3F);						// Формирование адреса.
	for (i = 0; i < 4; i++)													// Переворот адреса.
    {
		Command[1 + i] = ((unsigned char *)&Address)[3 - i];
    }
	WriteFile(hCOM, Command, 5, (LPDWORD)&i, NULL);							// Отправка команды.
	WriteFile(hCOM, Buffer, 4 * CountDoubleWord, (LPDWORD)&i, NULL);		// Отправка значения.
	if (i != 4*CountDoubleWord)												// Проверка выполнения команды.
    {
		cout << "Ошибка записи, проверьте подключение.\a" << endl;
		return 0;
    }
	return 1;
}

/****************************************************************************
* Init – Функция инициализации COM - порта.                                 *
*****************************************************************************
* Локальные переменные:                                                     *
* Test – переменная, хранящая инициализирующие данные;						*
* TestChar – массив, хранящий промежуточные значения;						*
* i – переменная, хранящая количество записываемых двойных слов.			*
****************************************************************************/

int Init()																				
{
	int Test = 0x55, i = 0;
	unsigned char TestChar[30] = {0}; 
	WriteFile(hCOM, &Test, 1, (LPDWORD)&i, NULL);							// Двойная запись инициализирующих данных.
	WriteFile(hCOM, &Test, 1, (LPDWORD)&i, NULL);
	if(!(Mem(0x90000000, 1, TestChar)))										// Проверка выполнения команды.
		return 0; 
	TestChar[3] |= (unsigned char)0xF;										// Включение отладочных компанентов.
	Wmem(0x90000000, 1, TestChar);
	return 1;
}

/****************************************************************************
* InitFull – Функция первоначальной инициализации COM - порта.              *
*****************************************************************************
* Локальные переменные:                                                     *
* dcb - структура, описывающая основные параметры COM порта;			    *
* to - структура, описывающая временные параметры COM порта;				*
* Config – переменная для работы с конфигурациями;                          *
* FullNameCOM, ShortNameCOM – переменные, хранящие имя COM порта.           *
****************************************************************************/

int InitFull()																			
{	

	COMMTIMEOUTS to;
	DCB dcb;
	ifstream Config;
	Config.open("config.txt");												// Чтение номера COM порта.
	char FullNameCOM[9] = "\\\\.\\", ShortNameCOM[5];
	Config >> ShortNameCOM;
	strcat(FullNameCOM, ShortNameCOM);		    							// Формирование COM порта.
	hCOM = CreateFile(FullNameCOM,											// Подключение к COM порту.
    GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
	Config.close();
	if (hCOM != INVALID_HANDLE_VALUE)										// Проверка подключения к COM порту.
	{														
		memset(&dcb, 0, sizeof(dcb));										// Настройка параметров подключения.
		dcb.DCBlength = sizeof(dcb);
		if (GetCommState(hCOM, &dcb))
		{
			if (BuildCommDCB("baud=115200 parity=N data=8 stop=1 xon=off", &dcb))
			{
				dcb.fBinary = TRUE;
				SetCommState(hCOM, &dcb);									// Устанавливаем настройки.
                GetCommTimeouts(hCOM, &to);									// Берем настройки задержек.
                to.ReadIntervalTimeout = 10;								// Устанавливаем задержки.
                to.ReadTotalTimeoutMultiplier = 1;
                to.ReadTotalTimeoutConstant = 1000;							// Ждем чтения 1 сек.
                to.WriteTotalTimeoutMultiplier = 1;
                to.WriteTotalTimeoutConstant = 10;
                if (SetCommTimeouts(hCOM, &to))
                {
                   SetupComm(hCOM, 16, 16);									// Применяем новые настройки инициализируем COM и устанавливаем размеры буферов.
                }
                else cout << GetLastError();
            }
            PurgeComm(hCOM, PURGE_TXABORT	| PURGE_RXABORT	| PURGE_TXCLEAR | PURGE_RXCLEAR);
            if (Init())														// Выполнение команды инициализации.
			{																// Проверка выполнения команды.
				cout << "Инициализация прошла успешно." << endl;
				return 1;
			}
		}
    }
	cout << "Ошибка подключения к \"" << ShortNameCOM << "\"." << endl;
	system("pause");
	exit(0);
	return 0;
}

/****************************************************************************
* isNum - Функция проверки парамметра на число.                             *
*****************************************************************************
* Формальный параметр:                                                      *
* p – массив, хранящий значение параметра.                                  *
*****************************************************************************
* Локальная переменная:                                                     *
* i – счетчик, для проверки элементов массива р.                            *
****************************************************************************/

int isNum(char *p)																		
{
	for (unsigned int i = 0; i < strlen(p); i++)
	{
		if (isalpha(p[i]))
			return 0;
	}
	return 1;
}

/****************************************************************************
* isHex - Функция проверки параметра на шеснадчатеричность.                 *
*****************************************************************************
* Формальный параметр:                                                      *
* p – массив, хранящий значение параметра.                                  *
*****************************************************************************
* Локальная переменная:                                                     *
* i – счетчик, для проверки элементов массива р.                            *
****************************************************************************/

int isHex(char *p)																		
{																
	for (unsigned int i = 0; i < strlen(p); i++)
	{
		if ( ! ((p[i] >= 'A' && p[i] <= 'F') || (p[i] >= 'a' && p[i] <= 'f') || (isdigit(p[i]))))
			return 0;
	}
	return 1;
}

/****************************************************************************
* isHexOrDec - Функция проверки параметра на разрядность.                   *
*****************************************************************************
* Формальные параметры:                                                     *
* p – строка, хранящая промежуточные значения;								*
* Data - переменная, возвращающая параметр в правильной разрядности.        *
****************************************************************************/

int isHexOrDec(char *p, int &Data)
{
	if(memcmp(p,"0x",2) == 0)
	{
		if (isHex(p+2))
			sscanf(p,"0x%X",&Data);
		else 
			return 0;
	}
	else if(isNum(p)) 
		sscanf(p,"%d",&Data);
	else 
		return 0;
	return 1;	
}

/****************************************************************************
* WriteSwap - Функция записи перевернутых данных.							*
*****************************************************************************
* Формальные параметры:                                                     *
* Address - переменная, хранящая адрес для записи;						    *
* swp - переменная, хранящая данные для записи;								*
****************************************************************************/

int WriteSwap(int Address,UInt32 swap)
{
	swp(swap);
	Wmem(Address, 1, (unsigned char *)&swap);		
	return 1;
}

/****************************************************************************
* ReadSwap - Функция чтения перевернутых данных.							*
*****************************************************************************
* Формальные параметры:                                                     *
* Address - переменная, хранящая адрес для записи;						    *
* UIntData - переменная, хранящая данные для чтения;						*
****************************************************************************/

int ReadSwap(int Address, UInt32 &UIntData )
{
	Mem(Address, 1 , ReadBuffer);														
	UIntData = *(UInt32 *)(&ReadBuffer);
	swp(UIntData);	
	return 1;
}

/****************************************************************************
* SwapReg - Функция переворота регистров.									*
*****************************************************************************
* Формальные параметры:                                                     *
* Address - переменная, хранящая адрес для записи;						    *
* Array[8] - массив, хранящий значения регистров;							*
*****************************************************************************
* Локальные переменные:                                                     *
* UIntData - переменная, хранящая промежуточные значения;				   	*
* i – счетчик, для прохождения по массиву.		                            *
****************************************************************************/

int SwapReg(int Address, int* Array)
{
	UInt32 *UIntData;
	for (int i=0; i<8; i++)
	{
		Mem (Address, 1 , ReadBuffer);
		UIntData = (UInt32 *)(&ReadBuffer);
		swp(*UIntData);
		Array[i] = (int)*UIntData;
		Address += 4;
	}
	return 1;
}

/****************************************************************************
* WriteBreak – Функция Записи точек остановок.								*
*****************************************************************************
* Локальные переменные:                                                     *
* Address – переменная, хранящая адрес для записи;                          *
* i – счетчик для прохождения по массиву.									*
****************************************************************************/

int WriteBreak()
{
	int Address = 0x90400010;												// Запись аппаратных точек.
	for ( int i = 0; i < 2; i++)
	{	
		WriteSwap(Address, ArrayWatch[0][i]);
		Address += 4;
		WriteSwap(Address, ArrayWatch[1][i]);
		Address += 4;
	}
	Address = 0x90400060;													// Запись программных точек.
	for (int i = 0; i < 4; i++)
	{
		WriteSwap(Address, ArrayBreak[0][i]);
		Address += 4 ;
		WriteSwap(Address, ArrayBreak[1][i]);
		Address += 4;
	}	
	return 1;
}

/****************************************************************************
* Help – Функция команды Help.												*
*****************************************************************************
* Локальные переменные:                                                     *
* Help – переменная, хранящая названия всех команд отладочного комплекса;   *
****************************************************************************/

int Help()
{
	string Help = "init - инициализация программы;\nclrscr - очистка экрана;\nmem - получение данных по указанному адресу;\n"
		"wmem - запись данных по указанному адресу;\ndebug_mode - команда активации/деактивации отладочного режима процессора;\n"
		"load - загрузка файла-приложения в память;\nrun - начать выполнение программы с указаннного адреса;\n"
		"watch - установка аппаратных точек остановок;\nbreak - установка программных точек остановок;\n"
		"delete - удаление точек остановки;\ncontinue - продолжение выполнения программы;\nstep - выполнение одного или нескольких шагов программы;\n"
		"write_break - запись точек остановок;\ndisassembler - дизассемблирование участка памяти;\nexit - выход из отладочного комплекса.\n";
	p = strtok('\0'," ");
	if(p)
	{
		if (!strcmp(p,"mem"))
			cout << "Команда mem \nОписание:\n  Получение данных по указанному адресу.\n"
			"Псевдонимы:\nПрототип: mem address [count]\n  address: int - адрес памяти для просмотра;\n"  
			"count: int - количество просматриваемых байт.\nПримечание:\n  Параметр count является опциональным."
			" В случае если он не указан, то значение по умолчанию принимается равным 64." << endl;
		else if (!strcmp(p,"wmem"))
			cout << "Команда wmem \nОписание:\n Запись данных по указанному адресу.\n"
			"Псевдонимы:\nПрототип: wmem address value\n  address: int - адрес памяти для просмотра;\n"  
			"value: int - значение для записи.\nПримечание:\n  Производит запись данных,"
			" представляющих собой последовательность 32-х разрядных слов, разделенных символом пробела по указанному адресу." << endl;
		else if ((!strcmp(p, "debug_mode")) || (!strcmp(p, "dm")))
			cout << "Команда debug_mode\nОписание:\n Команда активации/деактивации отладочного режима процессора.\n"
				"Псевдонимы: dm\nПрототип: dm enable_flag\n enable_flag - Признак активации отладочного режима процессора.\n"
				" Может иметь следующие значения:\n on - активировать отладочный режим;\nvoff - деактивировать отладочный режим.\nПримечание:\n" << endl;
		else if (!strcmp(p,"load"))
			cout << "Команда load\nОписание:\n Загрузка файла-приложения в память.\n"
			"Псевдонимы:\nПрототип: load address name\n address: int - адрес, с которого следует начать загругку файла-приложени;\n"  
			" name: - путь к файлу и его название.\nПримечание:\n  Файл-приложение должен иметь формать .bin."
			"  Если файл лежит в одной папке с программой, то путь можно не указывать." << endl;
		else if (!strcmp(p, "watch"))
			cout << "Команда watch\nОписание:\n Установка аппаратных точек остановок.\n"
				"Псевдонимы:\nПрототип: watch address\n  address: int - адрес точки остановки;\n"
				"Примечание:\n  В случае если параметр address не указан, то команда выведет всё заданные аппаратные точки остановки.\n"
				"  Максимальное количество аппаратных точек остановок - 2.\n"
				"  После установки всех точек остановок их нужно записать командой \"write_break\"." << endl;
		else if (!strcmp(p, "break"))
			cout << "Команда break\nОписание:\n Установка программных точек остановок.\n"
				"Псевдонимы:\nПрототип: break address\n  address: int - адрес точки остановки;\n"
				"Примечание:\n  В случае если параметр address не указан, то команда выведет всё заданные программные точки остановки.\n"
				"  Максимальное количество программных точек остановок - 4.\n"
				"  После установки всех точек остановок их нужно записать командой \"write_break\"." << endl;
		else if ((!strcmp(p, "delete")) || (!strcmp(p, "del")))
			cout << "Команда delete\nОписание:\n Удаление точек остановки.\n"
				"Псевдонимы: del\nПрототип: del number\n"
				"number: int (1 - 6) - номер точки остановки.\nПримечание:\n"
				" В случае если параметр number не указан, то команда выведет всё заданные точки остановки." << endl;
		else if (!strcmp(p, "run"))
			cout << "Команда run\nОписание:\n Начать выполнение программы с указаннного адреса.\n"
				"Псевдонимы:\nПрототип: run address\n address - Адрес откуда следует начать выполнение программы.\n" << endl;
		else if (!strcmp(p, "step"))
			cout << "Команда step\nОписание:\n Выполнение одного или нескольких шагов программы.\n"
				"Псевдонимы:\nПрототип: step [count]\n count: - количество выполняемых шагов.\n"
				"Примечание:\n  Параметр count является опциональным. В случае если он не указан, то значение по умолчанию принимается равным 1." << endl;
		else if ((!strcmp(p, "disassembler")) || (!strcmp(p, "dis")))
			cout << "Команда disassembler\nОписание:\n Дизассемблирование участка памяти.\n"
				"Псевдонимы: dis\nПрототип: disassembler address [count]\n address: int - адрес памяти для просмотра;\n"
				" count: int - количество просматриваемых двойных слов.\nПримечание:\n Параметр count является опциональным. "
				"В случае если он не указан, то значение по умолчанию принимается равным 16." << endl;
		else 
			cout << "Команды " << p << " не существует" << endl;
	}
	else cout << Help;
	return 0;
}

/****************************************************************************
* MenuMem - Функция команды Mem.											*
*****************************************************************************
* Локальные переменные:                                                     *
* Address – переменная, хранящая значение адреса для чтения;                *
* Sizemem, CountDoubleWord - переменные, хранящие количество двойных слов;  *
* UIntData - переменнная, хранящая промежуточные значения;					*
* i, j – счетчики, для вывода данных.		                                *
****************************************************************************/

int MenuMem()
{
	int Address, Sizemem;
	p = strtok('\0'," ");													// Проверка правильности параметров.
	if(!p)
	{
		cout << "Неправильный синтаксис команды \"mem\"." << endl << "Для получения справки наберите \"help mem\"." << endl;
		return 1;
	}
	if (!isHexOrDec(p, Address))
	{
		cout << "Неправильный формат адреса в команде \"mem\"." << endl << "Для получения справки наберите \"help mem\"." << endl;
		return 1;
	}
	p = strtok('\0'," ");
	
	if(p)
	{	
		if (!isNum(p))
		{
			cout << "Неправильный формат количества в команде \"mem\"." << endl << "Для получения справки наберите \"help mem\"." << endl;
			return 1;
		}
		Sizemem = atoi(p);
		Sizemem *= 4;
	}
	else Sizemem = 64;
		
	char ln[17];
	char *lnp = ln;

		for (int i = 0; i < Sizemem; i = i + 256)							// Определение размера данных для чтения.
		{
			int CountDoubleWord = 0;
			if ((i + 256 ) > Sizemem) 
			{
				CountDoubleWord = (Sizemem - i);
			}
			else
			{
				CountDoubleWord = 256;
			}
			if (!(Mem(Address + i, CountDoubleWord/4, ReadBuffer)))			// Выполнение команды чтения.
				break;

			for (int j = 0; j < CountDoubleWord; j = j + 4)					// Цикл для вывода данных.
			{
				UInt32 *UIntData;
				if (((i + j) % 16) == 0)
					printf("0x%08X ", Address + i + j);
				UIntData = (UInt32 *)(&ReadBuffer[j]);
				swp(*UIntData);	
				unsigned char * pp=(unsigned char *)UIntData;
				for(int h = 3; h >= 0 ; h--)	
				if((pp[h] >= 32) && (pp[h]<=127)) 
					*lnp++ = pp[h];								// Вывод символов.
				else
					*lnp++ = '.';								// Вывод символов.
				printf("%08X ", *UIntData);									// Вывод данных.
				if (((i + j) % 16) == 12)
				{
					printf("     ");
					*lnp = 0;
					puts(ln);
					lnp = ln;
				}
			}
		}
	printf("\n");
	return 0;
}

/****************************************************************************
* MenuWmem - Функция команды Wmem.											*
*****************************************************************************
* Локальные переменные:                                                     *
* Address – переменная, хранящая значение адреса для записи данных;         *
* Sizemem, CountDoubleWord - переменные, хранящие количество двойных слов;  *
* Data - переменнная, хранящая значения для записи.  						*
****************************************************************************/

int MenuWmem()
{
	int Address, Data, Sizemem = 0;;
	p = strtok('\0'," ");													// Проверка правильности парамметров.
	if(!p)
	{
		cout << "Неправильный синтаксис команды \"wmem\"." << endl << "Для получения справки наберите \"help wmem\"." << endl;
		return 1;
	}
	if (!isHexOrDec(p, Address))
	{
		cout << "Неправильный формат адреса в команде \"wmem\"." << endl << "Для получения справки наберите \"help wmem\"." << endl;
		return 1;
	}	
	p = strtok('\0'," ");
	while (p)
	{
		if (!isHexOrDec(p, Data))
		{
			cout << "Неправильный формат значения в команде \"wmem\"." << endl << "Для получения справки наберите \"help wmem\"." << endl;
			return 1;
		}
		swp((UInt32 &)Data);												// Переворот данных для записи.
		memcpy(WriteBuffer + Sizemem * 4, (char *)&Data, sizeof(Data));
		Sizemem++;
		p=strtok('\0'," ");
	}
	if (Sizemem = 0) 
	{
		cout << "Неправильный синтаксис команды \"wmem\"." << endl << "Для получения справки наберите \"help wmem\"." << endl;
		return 1;
	}
	Wmem(Address, Sizemem, WriteBuffer);									// Выполнение команды.
	cout << "Команда выполнена." << endl;
	return 0;
}

/****************************************************************************
* Load - Функция загрузки файла-приложения в память.						*
*****************************************************************************
* Локальные переменные:                                                     *
* LoadFile - указатель на загржаемый файл;								   	*
* LenFile - переменная, хронящая длину файла;								*
* Address – переменная, хранящая значение адреса для записи файла;          *
* i – счетчик, для записи файла.											*
****************************************************************************/

int Load()
{
	FILE *LoadFile;
	int LenFile = 0, Address, i;
	p = strtok('\0'," ");													// Проверка правильности парамметров.
	if(!p)																				
	{
		cout << "Неправильный синтаксис команды \"load\"." << endl << "Для получения справки наберите \"help load\"." << endl;
		return 1;
	}
	if (!isHexOrDec(p, Address))
	{
		cout << "Неправильный формат адреса в команде \"load\"." << endl << "Для получения справки наберите \"help load\"." << endl;
		return 1;
	}
	p = strtok('\0'," ");
	if(!p)
	{
		cout << "Неправильный синтаксис команды \"load\"." << endl << "Для получения справки наберите \"help load\"." << endl;
		return 1;
	}
	if((LoadFile = fopen(p,"rb")) == NULL)									// Открытие Файла.	
	{
		cout << "Файл \"" << p <<"\" не найден!" << endl;
		return 1;
	}
	LenFile = 0;
	fseek(LoadFile, 0 ,SEEK_SET);										
	while (!feof(LoadFile))													// Цикл прохода по файлу.
	{
		i = fread(WriteBuffer, 1, 256, LoadFile);
		Wmem(Address, i / 4, WriteBuffer);									// Запись Файла.
		Sleep(40);
		Address += i;
		LenFile++;
	}
	cout << "Файл загружен." << endl << "Размер файла: " << LenFile * 256 - 256 + i << " байт." << endl;
	fclose(LoadFile);	
	return 0;
}

/****************************************************************************
* Watch - Функция установки аппаратных точек остановок.						*
*****************************************************************************
* Локальные переменные:                                                     *
* BreakPoint – переменная, хранящая значение точки остановки;	            *
* i – счетчик, для прохождения по массиву.									*
****************************************************************************/

int Watch()
{
	int BreakPoint;
	p = strtok('\0'," ");													// Проверка правильности парамметров.
	if(p)
	{
		if (!isHexOrDec(p, BreakPoint))
		{
			cout << "Неправильный формат адреса в команде \"watch\"." << endl << "Для получения справки наберите \"help watch\"." << endl;
			return 1;
		}
		if (ArrayWatch[0][0] == NULL)										// Установка точек остановки.
		{
			ArrayWatch[0][0] = BreakPoint;
			ArrayWatch[1][0] = 0xFFFFFFFF;
			CountWatch++;
		}
		else if (ArrayWatch[0][1] == NULL)
		{					
			ArrayWatch[0][1] = BreakPoint;
			ArrayWatch[1][1] = 0xFFFFFFFF;
			CountWatch++;
		}
		else 
		{
			cout << "Задано максимальное количество аппаратных точек остановок." << endl;
			return 1;
		}
		cout << "Аппаратная точка остановки задана." << endl;	
		return 1;
	}
	cout << "Аппаратные точки остановки:" << endl;							// Вывод точек остановок.
	for (int i = 0; i < 2; i++)
		if (ArrayWatch[0][i] != 0)
			printf("%d : 0x%08X\n", i + 1 , ArrayWatch[0][i]);
	return 0;
}

/****************************************************************************
* Break - Функция установки программных точек остановок.					*
*****************************************************************************
* Локальные переменные:                                                     *
* BreakPoint – переменная, хранящая значение точки остановки;	            *
* i – счетчик, для прохождения по массиву.									*
****************************************************************************/

int Break()
{
	int BreakPoint;
	p = strtok('\0'," ");													// Проверка правильности парамметров.
	if(p)
	{
		if (!isHexOrDec(p, BreakPoint))
		{
			cout << "Неправильный формат адреса в команде \"watch\"." << endl << "Для получения справки наберите \"help watch\"." << endl;
			return 1;
		}
		if (ArrayBreak[0][0] == NULL)										// Установка точек остановки.
		{
			ArrayBreak[0][0] = BreakPoint | 0x1;
			ArrayBreak[1][0] = 0xFFFFFFFC;
		}
		else if (ArrayBreak[0][1] == NULL)
		{					
			ArrayBreak[0][1] = BreakPoint | 0x1;
			ArrayBreak[1][1] = 0xFFFFFFFC;
		}
		else if (ArrayBreak[0][2] == NULL)
		{
			ArrayBreak[0][2] = BreakPoint | 0x1;
			ArrayBreak[1][2] = 0xFFFFFFFC;
		}
		else if (ArrayBreak[0][3] == NULL)
		{					
			ArrayBreak[0][3] = BreakPoint | 0x1;
			ArrayBreak[1][3] = 0xFFFFFFFC;
		}
		else 
		{
			cout << "Задано максимальное количество программных точек остановок." << endl;
			return 1;
		}
	cout << "Программная точка остановки задана." << endl;
	return 1;
	}
	cout << "Программные точки остановки:" << endl;
	for (int i = 0; i < 4; i++)												// Вывод точек остановок.
		if (ArrayBreak[0][i] != 0)
			printf("%d : 0x%08X\n", i + 1 , ArrayBreak[0][i]);
	return 0;
}

/****************************************************************************
* Delete - Функция удаления точек остановок.								*
*****************************************************************************
* Локальные переменные:                                                     *
* index – переменная, хранящая индекс точки остановки;					    *
* i – счетчик, для прохождения по массиву.									*
****************************************************************************/

int Delete()
{
	int Index;
	p = strtok('\0'," ");													// Проверка правильности парамметров.
	if(p)
	{
		Index = atoi(p);
		if (!(Index >= 1 && Index <= 6))
		{
			cout << "Неправильный формат индекса в команде \"delete\"." << endl << "Для получения справки наберите \"help delete\"." << endl;
			return 1;
		}
		if ((Index - 1 < 2) && (CountWatch > 0) && (ArrayWatch[0][Index - 1] != 0))	
		{
			for (int i = Index - 1; i < 1; i++)
			{
				ArrayWatch[0][i] = ArrayWatch[0][i + 1];					// Удаление аппаратных точек остановки.
				ArrayWatch[1][i] = ArrayWatch[1][i + 1];
			}
			ArrayWatch[0][1] = 0; ArrayWatch[1][1] = 0;
			CountWatch--;
			cout << "Точка остановки удалена." << endl;
			return 1;
		}
		else if (ArrayBreak[0][Index - (1 + CountWatch)] != 0)				
		{
			
			for (int i = Index - (1 + CountWatch); i < 3; i++)
			{
				ArrayBreak[0][i] = ArrayBreak[0][i + 1];					// Удаление программных точек остановки.
				ArrayBreak[1][i] = ArrayBreak[1][i + 1];
			}
			ArrayBreak[0][3] = 0; ArrayBreak[1][3] = 0;
			cout << "Точка остановки удалена." << endl;
			return 1;
		}
		else 
		cout << "Точка остановки " << Index << " не задана." << endl;
		return 1;
	}
	cout << "Аппаратные точки остановки:" << endl;							// Вывод точек остановок.
	Index = 0;
	for (int i = 0; i < 6; i++)
	{
		if(i == 2)
		cout << "Программные точки остановки:" << endl;
		if ((i < 2) && (ArrayWatch[0][i] != 0))
			printf("%d : 0x%08X\n", ++Index, ArrayWatch[0][i]);
		else if ((i > 1) && (ArrayBreak[0][i - 2] != 0))
			printf("%d : 0x%08X\n", ++Index, ArrayBreak[0][i - 2]);
	}
	return 0;
}

/****************************************************************************
* Run - Функция выполнения программы с указаннного адреса.					*
*****************************************************************************
* Локальные переменные:                                                     *
* Address - переменная, хранящая адрес для запуска программы;			   	*
* UIntData - переменная, хранящая промежуточные значения;				   	*
* i – счетчик, для прохождения по массиву.									*
****************************************************************************/

int Run()
{
	int Address;
	p = strtok('\0'," ");													// Проверка правильности парамметров.
	if(!p)
	{
		cout << "Неправильный синтаксис команды \"run\"." << endl << "Для получения справки наберите \"help run\"." << endl;
		return 1;
	}
	if (!isHexOrDec(p, Address))
	{
		cout << "Неправильный формат адреса в команде \"run\"." << endl << "Для получения справки наберите \"help run\"." << endl;
		return 1;
	}
	
	WriteSwap(0x90400010, Address);											// Запись первой команды.
	Sleep(10);
	WriteSwap(0x90400014, Address + 4);										// Запись следующей команды.
	Mem(0x90000000, 1, ReadBuffer);											// Включение режима остановки процессора в случае ошибок.
	ReadBuffer[2] |= 0x2;
	Wmem(0x90000000, 1, ReadBuffer);
	WriteBreak();															// Запись точек остановок.
	memset(WriteBuffer, 0, 4);
	Wmem(0x90000020, 1, WriteBuffer);										// Запуск программы.
	Wmem(0x90000024, 1, WriteBuffer);
	do																		// Проверка на остановку процессора.
	{
		Sleep(40);
		Mem(0x90000000, 1, ReadBuffer);	
	}
	while((ReadBuffer[3] & 0x40) == 0);
	Mem(0x90400010, 1, ReadBuffer);											// Анализ остановки процессора.
	UInt32 *UIntData = (UInt32 *)(ReadBuffer);
	swp(*UIntData);
	for (int i = 0; i <= 4; i++)
		if ((*UIntData == ArrayWatch[0][i]) || ((*UIntData == (ArrayBreak[0][i] & ( ~ 0x1)))))
			cout << "Программа достигла точки остановки:" << *UIntData << endl;
	return 0;
}

/****************************************************************************
* Step - Функция выполнения одного или нескольки шагов программы.			*
*****************************************************************************
* Локальные переменные:                                                     *
* NumberOfSteps - переменная, хранящая количество шагов для выполнение;   	*
* i – счетчик, количества шагов.											*
****************************************************************************/

int Step()
{
	int NumberOfSteps = 1;
	WriteBreak();															// Запись точек остановок.
	p = strtok('\0'," ");													// Проверка правильности парамметров.
	if(p)
	{
		if (!isNum(p))
		{
			cout << "Неправильный параметр в команде \"step\"." << endl << "Для получения справки наберите \"help step\"." << endl;
			return 1;
		}	
		NumberOfSteps = atoi(p);
	}
	for(int i = 0; i < NumberOfSteps; i++)									// Выполнение шагов программы.
	{
		Mem(0x90400010, 1, ReadBuffer);
		Wmem(0x90000020, 1, (unsigned char *)0x10001000);
		Wmem(0x90000020, 1, (unsigned char *)0x00001000);
		Disassemble((UInt32)ReadBuffer, (UInt32)0x90400010, (char *)WriteBuffer, false);
		cout << ReadBuffer << WriteBuffer << endl;
	}
	return 0;
}

/****************************************************************************
* Continue - Функция продолжения выполнения программы.						*
*****************************************************************************
* Локальные переменные:                                                     *
* UIntData - переменная, хранящая промежуточные значения;				   	*
* i – счетчик, для прохождения по массиву.									*
****************************************************************************/

int Continue()
{
	WriteBreak();															// Запись точек остановок.
	Mem(0x90000000, 1, ReadBuffer);
	if ((ReadBuffer[3] & 0xF) != 0xF)										// Проверка на на вкл. отл. средств.
	{
		memcpy(WriteBuffer,ReadBuffer,4);									// Копировние 1 слова из ReadBuffer в WriteBuffer.
		WriteBuffer[3] |= (unsigned char)0xF;
		Wmem(0x90000000, 1, WriteBuffer);
	}
	memset(WriteBuffer,0,4);
	Wmem(0x90000020, 1, WriteBuffer);										// Запуск программы.
	Wmem(0x90000024, 1, WriteBuffer);
	do																		// Проверка на остановку процессора.
	{
		Sleep(40);
		Mem(0x90000000, 1, ReadBuffer);
	} while ((ReadBuffer[3] & 0x40) == 0);
	Mem(0x90400010, 1, ReadBuffer);											// Анализ остановки процессора.
	UInt32 *UIntData = (UInt32 *)(ReadBuffer);
	swp(*UIntData);
	for (int i = 0; i <= 4; i++)
	if ((*UIntData == ArrayWatch[0][i]) || ((*UIntData == (ArrayBreak[0][i] & (~0x1)))))
		cout << "Программа достигла точки остановки:" << *UIntData << endl;
	return 0;
}

/****************************************************************************
* DebugMode - Функция активации/деактивации отладочного режима процессора.	*
****************************************************************************/

int DebugMode()
{
	p = strtok('\0'," ");													// Проверка правильности парамметров.
	if(!p)
	{
		cout << "Неправильный синтаксис команды \"debug_mode\"." << endl << "Для получения справки наберите \"help debug_mode\"." << endl;
		return 1;
	}
	Mem(0x90000000, 1, ReadBuffer);
	if ((ReadBuffer[3] & 0xF) != 0xF)										// Проверка на на вкл. отл. средств.
	{
		memcpy(WriteBuffer,ReadBuffer,4);									// Копировние 1 слова из ReadBuffer в WriteBuffer.
		WriteBuffer[3] |= (unsigned char)0xF;
		Wmem(0x90000000, 1, WriteBuffer);
	}
	if ((ReadBuffer[3] & 0x40) == 0x0)										// Проверка на включеннный отладочный режим.
	{
		if (!strcmp(p, "on"))												// Включение отладочного режима.
		{	
			memset(WriteBuffer, 0, 4);
			WriteBuffer[3] = (unsigned char)0xF;
			Wmem(0x90000020, 1, WriteBuffer);
			Wmem(0x90000024, 1, WriteBuffer);
			cout << "Процессор находится в отладочном режиме" << endl;
		}
		else if (!strcmp(p, "off"))
		{
			cout << "Процессор не находится в отладочном режиме" << endl;
		}
		else
		{
			cout << "Неправильный синтаксис команды \"debug_mode\"." << endl << "Для получения справки наберите \"help debug_mode\"." << endl;
			return 1;
		}
	}
	else
	{
		if (!strcmp(p, "on"))
		{
			cout << "Процессор находится в отладочном режиме" << endl;
		}
		else if (!strcmp(p, "off"))											// Выключение отладочного режима.
		{
			memset(WriteBuffer, 0, 4);
			Wmem(0x90000020, 1, WriteBuffer);
			Wmem(0x90000024, 1, WriteBuffer);
			cout << "Процессор не находится в отладочном режиме" << endl;
		}
		else
		{
			cout << "Неправильный синтаксис команды \"debug_mode\"." << endl << "Для получения справки наберите \"help debug_mode\"." << endl;
			return 1;
		}
	}
	return 0;
}

/****************************************************************************
* Disassembler - Функция дизассемблирования участка памяти.					*
*****************************************************************************
* Локальные переменные:                                                     *
* Address – переменная, хранящая значение адреса для дизассемблирования;    *
* Sizemem, CountDoubleWord - переменные, хранящие количество двойных слов;  *
* UIntBuffer - переменнная, хранящая промежуточные значения;				*
* i, j – счетчики, для вывода данных.		                                *
****************************************************************************/

int Disassembler()
{
	int Address, Sizemem = 64, CountDoubleWord = 0;
	p = strtok('\0'," ");													// Проверка правильности парамметров.
	if(!p)
	{
		cout << "Неправильный синтаксис команды \"disassembler\"." << endl << "Для получения справки наберите \"help disassembler\"." << endl;
		return 1;
	}
	if (!isHexOrDec(p, Address))
	{
		cout << "Неправильный формат адреса в команде \"disassembler\"." << endl << "Для получения справки наберите \"help disassembler\"." << endl;
		return 1;
	}
	p = strtok('\0'," ");
	if(p)
	{	
		if (!isNum(p))
		{
			cout << "Неправильный формат количества в команде \"disassembler\"." << endl << "Для получения справки наберите \"help disassembler\"." << endl;
			return 1;
		}
		Sizemem = atoi(p);
		Sizemem *= 4;
	}
	else Sizemem = 64;
	for (int i = 0; i < Sizemem; i = i + 256)								// Определение размера данных для дизассемблирования.
	{
		if ((i + 256 ) > Sizemem) 
		{
			CountDoubleWord = (Sizemem - i);
		}
		else
		{
			CountDoubleWord = 256;
		}
		if (!(Mem(Address + i, CountDoubleWord / 4, WriteBuffer)))			// Чтение данных для дизассемблирования.
			break;
		for (int j = 0 ; j < CountDoubleWord; j = j + 4)					// Выполнение дизассемблирования.
		{
			UInt32 *UIntBuffer;
			printf("0x%08X ", Address + i + j);
			UIntBuffer = (UInt32 *)(&WriteBuffer[j]);
			swp(*UIntBuffer);	

			Disassemble((UInt32)*UIntBuffer, (UInt32)(Address + i + j), (char *)ReadBuffer, false);
				printf("0x%08X ", *UIntBuffer);								// Вывод дзассемблируемых данных.
				cout << " " << ReadBuffer;
		}
	}
	return 0;
}

/****************************************************************************
* Reg - Функция вывода регистров окна.										*
*****************************************************************************
* Локальные переменные:                                                     *
* ArrayIns, ArrayLocals, ArrayOuts ,ArrayGlobals - Массивы хранящие			*		
* значения регистров;														*
* ArrayReg - массив хранящий названия основных регистров;					*
* Window - переменная, хранящая номер окна;									*
* Address – переменная, хранящая значение адреса регистров;					*
* UIntData, UIntAddress - переменнные, хранящие промежуточные значения;		*
* i – счетчик, для вывода данных.											*
****************************************************************************/

int Reg()
{
	int ArrayIns[8] = { 0 }, ArrayLocals[8] = { 0 }, ArrayOuts[8] = { 0 }, ArrayGlobals[8] = { 0 }, Window, Address;
	char* ArrayReg[4] = {"y", "psr", "wim", "trb"};
	UInt32 UIntData, UIntAddress;
	p = strtok('\0'," ");													// Проверка правильности парамметров.
	if(p)
	{
		Window = atoi(p);
		if (!(Window >= 0 && Window <= 7))
		{
			cout << "Неправильный формат индекса в команде \"reg\"." << endl << "Для получения справки наберите \"help reg\"." << endl;
			return 1;
		}
	}	
	else
	{
		Mem(0x90400004, 1 , ReadBuffer);
		Window = (int)ReadBuffer & 7;
	}
	Address = 0x90300000 + (((Window * 64) + 96 + 0 * 4) %(8 * 64));		// Чтение регистров окна.
	SwapReg(Address, ArrayIns);
	Address = 0x90300000 + (((Window * 64) + 64 + 0 * 4) %(8 * 64));
	SwapReg(Address, ArrayLocals);
	Address = 0x90300000 + (((Window * 64) + 32 + 0 * 4) %(8 * 64));
	SwapReg(Address, ArrayOuts);
	Address = 0x90300000 + (8 * 64);
	SwapReg(Address, ArrayGlobals);
	printf("          Ins           Locals           Outs          Globals\n");	
	for (int i = 0; i < 8; i++)												// Вывод регистров окна.
	{
		printf("%   d :   0x%08X     0x%08X      0x%08X     0x%08X\n", i, ArrayIns[i], ArrayLocals[i], ArrayOuts[i], ArrayGlobals[i]);
	}
	printf("\n");				
	Address = 0x90400000;													// Чтение основных регистров.
	for (int i = 0; i < 4; i++)
	{
		ReadSwap(Address, UIntData);
		printf(" %s : 0x%08X", ArrayReg[i], UIntData);
		Address += 4;
	}
	printf("\n\n");								
	ReadSwap(0x90400010, UIntAddress);										// Дизассемблирование регистров команд.
	ReadSwap(UIntAddress, UIntData);
	Disassemble(UIntData, UIntAddress, (char *)WriteBuffer, false);
	printf(" pc : 0x%08X 0x%08X", UIntAddress, UIntData);
	cout << " " << WriteBuffer;
	ReadSwap(0x90400014, UIntAddress);
	ReadSwap(UIntAddress, UIntData);
	Disassemble(UIntData, UIntAddress, (char *)WriteBuffer, false);
	printf("npc : 0x%08X 0x%08X", UIntAddress, UIntData);
	cout << " " << WriteBuffer;
	return 1;	
}

/****************************************************************************
* main - Функция основной программы.										*
*****************************************************************************
* Локальная переменная:                                                     *
* menu – переменная, хранящая название команды.							    *
****************************************************************************/

int main()
{
	setlocale(LC_ALL, "Rus");
	char menu[300] = {0};
	cout << "Это отладочный комплекс для процессора с архетектурой Sparc v8." << endl;
	InitFull();
	while (1)																// Цикл работы меню.
	{
	    printf(">");
	    gets(menu);
	    if(strlen(menu))													// Определение команды.
        {
            p = strtok(menu," ");
            if (!strcmp(menu,"help"))
				Help();
			else if (!strcmp(p,"mem"))
				MenuMem();
			else if (!strcmp(p,"wmem"))
				MenuWmem();
			else if ((!strcmp(p, "debug_mode")) || (!strcmp(p, "dm")))
				DebugMode();
			else if (!strcmp(p,"load"))
				Load();
			else if (!strcmp(p,"watch"))
				Watch();
			else if (!strcmp(p,"break"))	
				Break();
			else if ((!strcmp(p,"delete")) || (!strcmp(p,"del")))
				Delete();
			else if (!strcmp(p,"run"))
				Run();
			else if (!strcmp(p,"step"))
				Step();
			else if (!strcmp(p, "continue"))
				Continue();
			else if ((!strcmp(p, "write_break")) || (!strcmp(p, "wb")))
				{
				if (WriteBreak())
					cout << "Точки остановок записаны." << endl;
				}
			else if (!strcmp(p,"init"))	
				if (Init())
					cout << "Инициализация прошла успешно." << endl;
				else
					cout << "Инициализация не выполнена." << endl;
			else if ((!strcmp(p,"disassembler")) || (!strcmp(p,"dis")))
				Disassembler();
			else if (!strcmp(p,"reg"))
				Reg();
			else if (!strcmp(p,"clrscr"))    
				system("cls");
			else if (!strcmp(p,"exit"))    
				 return 1;
            else
				 cout << "Команды " << menu << " не существует" << endl;
		}
	}
	system("pause");
	PurgeComm(hCOM, PURGE_TXABORT | PURGE_RXABORT | PURGE_TXCLEAR | PURGE_RXCLEAR);
	CloseHandle(hCOM);
	return 0;
}                                                                                       
